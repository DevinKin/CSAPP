# 第2章-信息的表示和处理

- 无符号编码基于传统的二进制表示法，表示大于或者等于零的数字。

- 补码（two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。

- 浮点数（floating-point）编码是表示实数的科学计数法的以2为基数的版本。

- C语言的版本和GCC命令行选项

  |    C版本     |  GCC命令行选项  |
  | :----------: | :-------------: |
  |    GNU89     | 无，-std=gnu89  |
  | ANSI,ISO C90 | -ansi，-std=c89 |
  |   ISO C99    |    -std=c99     |
  |   ISO C11    |    -std=c11     |

## 信息存储

- 大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。
- 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。
- 内存的每个字节都由一个唯一的数字来标识，称为它的地址。所有可能地址的集合就称为虚拟地址空间。
- C编译器还把每个指针和类型信息联系起来，这样可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。但是它生成的机器级程序并不包含关于数据类型的信息。

### 字数据大小

- 字长：在同一时间中处理二进制数的位数。32位CPU同一时间处理字长为32位二进制数据。
- 地址总线的位数决定了CPU可直接寻址的内存空间大小。若地址总线为n位，则寻址空间为$2^{n-10}$字节。
- 每台计算机都有一个字长（word size），指明指针数据的标称大小（norminal size）。
- 因为虚拟地址是以一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。
- 一个字长为$w$位的机器而言，虚拟地址的范围为$0～2^w - 1$，程序最多访问$2^w$个字节。
- 可移植性的一个方面是使程序对不同数据类型的确切大小不敏感。

#### 寻址和字节顺序

- 对于跨越多字节的程序对象，我们必须建立两个规则
  - 这个对象的地址是什么？
  - 在内存中如何排列这些字节？
- 排列表示一个对象的字节有两个通用的规则
  - 最低有效字节在前面的方式，称为小端法（little ending）。
  - 最高有效字节在前面的方式，称为大端法（big ending）。
- 书写字节序列的自然方式是最低位字节在左边，最高位字节在右边。

### 布尔代数简介

- 位向量就是固定长度为$w$，由0和1组成的串。
- 位向量的运算可以定义成参数的每个对应元素之间的运算。假设$a$和$b$分别表示位向量$[ a_{w-1}，a_{w-2}，\cdots，a_0]$和$[ b_{w-1}，b_{w-2}，\cdots，b_0]$，我们将`a&b`也定义为一个长度为$w$的位向量，其中第i个元素等于${a_i}$&$b_i$，$0 \le i \lt w$。
- 位向量一个很有用的应用就是表示有限集合。我们可以用位向量$[ a_{w-1}，a_{w-2}，\cdots，a_0]$编码任何子集$ A \subseteq {0，1，\cdots，w - 1}$，其中$a_i = 1$当且仅当$i \in A$。
- 位向量$a \dot = [01101001]$表示集合$A = { 0,3,5,6}$，位向量$b \dot = [01010101]$表示集合$A = {0,2,4,6}$。

### C语言中的位级运算

- C语言位运算符。
  - `~`位运算NOT
  - `&`位运算AND
  - `|`位运算OR
  - `^`位运算异或（EXCLUSIVE-OR）

### C语言中的逻辑运算

- C语言的逻辑运算
  - `||`逻辑或
  - `&&`逻辑与
  - `!`逻辑非
- 逻辑运算与位运算的区别
  - 逻辑运算对第一个参数求值就能确定表达式的结果，那么逻辑运算符不会对第二个参数求值。

### C语言中的移位运算

- 移位运算是从左至右可结合的，所以$x<<j<<k$等价于$(x<<j)<<k$。
- x左移k位，丢弃最高的k位，并在右端补k个0。
- 一般而言，机器支持两种形式的右移
  - 逻辑右移。逻辑左移在在左端补k个0，得到的结果是$[ 0,\cdots,0,x_{w-1},x_{w-2},\cdots,x_k ]$
  - 算术右移。在左端补k个最高有效位的值，得到的结果是$ [ x_{w-1},\cdots,x_{w-1},x_{w-2}, \cdots ,x_k]$
- 几乎所有的编译器/机器组合都对有符号数使用算术右移。
- 对于无符号数，右移必须是逻辑的。

## 整数表示

|    符号     | 类型 |       含义       |
| :---------: | :--: | :--------------: |
|  $B2T_{w}$  | 函数 |   二进制转补码   |
|   $B2U_w$   | 函数 | 二进制转无符号数 |
|   $U2B_w$   | 函数 | 无符号数转二进制 |
|   $U2T_w$   | 函数 |  无符号数转补码  |
|   $T2B_w$   | 函数 |   补码转二进制   |
|   $T2U_w$   | 函数 |  补码转无符号数  |
|  $TMin_w$   | 常数 |    最小补码值    |
|  $TMax_w$   | 常数 |    最大补码值    |
|  $UMax_w$   | 常熟 |   最大无符号数   |
| $+_{w}^{t}$ | 操作 |     补码加法     |
|   $+_w^u$   | 操作 |   无符号数加法   |
|   $*_w^t$   | 操作 |     补码乘法     |
|   $-_w^t$   | 操作 |     补码取反     |
|   $-_w^u$   | 操作 |   无符号数取反   |

- C和C++都支持有符号（默认）和无符号数。Java只支持有符号数。

### 无符号数的编码

- 无符号数编码的定义：对于向量$\vec{x} = [ x_{w-1},x_{w-2}, \cdots, x_0]$
  $$
  B2U_w (\vec{x}) \dot= \sum_{i=0}^{w-1}x_i2^i
  $$

- 符号$\dot=$表示左边被定义为等于右边。

- 函数$B2U_w$将一个长度为$w$的0,1串映射到非符整数。

- 整数值$UMax_w\dot=\sum_{i=0}^{w-1}2^i=2^w - 1$。

- 无符号数的二进制表示有一个很重要的属性，也就是每个介于$0～2^w-1$之间的数都有唯一一个$w$位的值编码。

- 无符号数编码的唯一性：函数$B2U_w$是一个双射。

### 补码编码

- 最常见的有符号数的计算机表示方式就是补码形式。

- 补码的定义是，将最高有效位解释为负权（negative weight）。

- 用函数$B2T_w$来表示补码。

- 补码编码的定义：对向量$\vec{x} = [ x_{w-1},x_{w-2}, \cdots, x_0]$
  $$
  B2T_w(\vec{x}) \dot= -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i
  $$

- 补码能表示的最小值$TMin_w\dot=-2^{w-1}$。

- 补码能表示的最大值$TMax_w\dot=\sum_{i=0}^{w-2}2^i=2^{w-1}-1$。

- 补码编码的唯一性：函数$B2T_w$是一个双射。

- 补码的范围是不对称的：$|TMin| = | TMax | + 1$。

- 最大无符号数值刚好比补码的最大值的两倍大一点：$Uax_w=2TMax_w + 1$。

- 补码表示中所有表示负数的位模式在无符号表示中都变成了整数。$-1$和$UMax$有同样的位表示（一个全1的串）。

#### 有符号数的其他表示方法

- 反码（Ones's COmplement）：除了最高有效位的权是$-(2^{w-1} - 1)$而不是$-2^{w-1}$，它和补码是一样的。
  $$
  B2O_w(\vec{x})\dot=-x_{w-1}(2^{w-1} - 1) + \sum_{i=0}^{w-2}x_i2_i
  $$

- 原码（Sign-Magnitude）：最高有效位是符号位，用来确定剩下的位应该取负权还是正权。
  $$
  B2S_w(\vec{x})\dot=(-1)^{x_{w-1}} \cdot(\sum_{i=0}^{w-2}x_i2_i)
  $$

- 这两种方法对于数字0有两种不同的编码方式。把$[00\cdots0]$都解释为+0。而值$-0$在在原码中表示$[10\cdots0]$，在反码中表示为$[11\cdots1]$。

### 有符号数和无符号数之间的转换